import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Textarea } from "@/components/ui/textarea";
import { Scan, Play, Pause, Square, Network, Globe, Server, Monitor, Upload, AlertTriangle } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "@/hooks/useAuth";
import { NotificationCenter } from "./NotificationCenter";

export const VulnerabilityScanner = () => {
  const [isScanning, setIsScanning] = useState(false);
  const [scanProgress, setScanProgress] = useState(0);
  const [selectedScanType, setSelectedScanType] = useState("quick");
  const [scanName, setScanName] = useState("");
  const [targetInputs, setTargetInputs] = useState("");
  const [isUploading, setIsUploading] = useState(false);
  const [recentScans, setRecentScans] = useState<any[]>([]);
  const { toast } = useToast();
  const { user, profile } = useAuth();

  const scanTypes = [
    { 
      id: "quick", 
      name: "Quick Scan", 
      path: "/nuclei-templates/passive/cves",
      description: "Passive CVE detection scan" 
    },
    { 
      id: "cve", 
      name: "CVE Scan", 
      path: "/nuclei_templates/http/CVE/",
      description: "Comprehensive CVE vulnerability scan" 
    },
    { 
      id: "full", 
      name: "Full Scan", 
      path: "/nuclei_templates/",
      description: "Complete nuclei template scan" 
    },
    { 
      id: "subdomain", 
      name: "Subdomain Takeover", 
      path: "/nuclei-templates/http/takeovers/",
      description: "Subdomain takeover vulnerability scan" 
    },
  ];

  useEffect(() => {
    fetchRecentScans();
  }, []);

  const fetchRecentScans = async () => {
    try {
      const { data, error } = await supabase
        .from('nuclei_scan_results')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(5);
      
      if (error) throw error;
      
      const scansWithStats = await Promise.all(
        (data || []).map(async scan => {
          // Get vulnerability counts
          const { count, error: countError } = await supabase
            .from('nuclei_vulnerabilities')
            .select('*', { count: 'exact', head: true })
            .eq('scan_id', scan.id);
          
          if (countError) throw countError;
          
          return {
            ...scan,
            vulnerabilities: count || 0
          };
        })
      );
      
      setRecentScans(scansWithStats);
    } catch (error) {
      console.error('Error fetching recent scans:', error);
    }
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (!file.name.endsWith('.txt')) {
      toast({
        title: "Invalid File Type",
        description: "Please upload a .txt file containing target URLs/IPs",
        variant: "destructive",
      });
      return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
      const content = e.target?.result as string;
      setTargetInputs(content);
      toast({
        title: "File Uploaded",
        description: `Loaded ${content.split('\n').filter(line => line.trim()).length} targets from file`,
      });
    };
    reader.readAsText(file);
  };

  const handleResultUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (!file.name.endsWith('.json') && !file.name.endsWith('.jsonl')) {
      toast({
        title: "Invalid File Type",
        description: "Please upload a .json or .jsonl file containing nuclei scan results",
        variant: "destructive",
      });
      return;
    }

    setIsUploading(true);

    try {
      const content = await file.text();
      let results;

      // Handle both JSON and JSONL formats
      if (file.name.endsWith('.jsonl')) {
        // Parse JSONL (each line is a JSON object)
        results = content.split('\n')
          .filter(line => line.trim())
          .map(line => {
            try {
              return JSON.parse(line);
            } catch (e: any) {
              throw new Error(`Invalid JSONL format: ${e.message}`);
            }
          });
      } else {
        // Parse regular JSON
        try {
          results = JSON.parse(content);
        } catch (e: any) {
          throw new Error(`Invalid JSON format: ${e.message}`);
        }
      }

      // Ensure results is an array
      if (!Array.isArray(results)) {
        results = [results];
      }

      // Store the scan results
      const scanId = `scan_${Date.now()}`;
      const { data: scanData, error: scanError } = await supabase
        .from('nuclei_scan_results')
        .insert({
          scan_name: scanName || `Uploaded scan ${new Date().toLocaleString()}`,
          scan_type: selectedScanType,
          results: results
        })
        .select();

      if (scanError) throw scanError;

      // Process each vulnerability from the results
      const vulnerabilities = results.map((result: any) => ({
        scan_id: scanData?.[0]?.id ? String(scanData[0].id) : scanId,
        vuln_id: result.id || result['template-id'] || 'unknown',
        template_name: result.info?.name || result.name || 'Unknown',
        vuln_hash: result.hash || `${result.host}_${result['template-id']}_${Date.now()}`,
        matcher_name: result['matcher-name'] || result.matcher,
        matcher_status: result['matcher-status'] !== false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        severity: result.info?.severity || result.severity || 'info',
        host: result.host || 'unknown',
        matched_at: result['matched-at'] || result.timestamp || new Date().toISOString(),
        template_id: result['template-id'] || result.template || result.id || 'unknown',
        description: result.info?.description || result.description || '',
        vuln_status: 'open'
      }));

      // Insert vulnerabilities
      const { error: vulnError } = await supabase
        .from('nuclei_vulnerabilities')
        .insert(vulnerabilities);

      if (vulnError) throw vulnError;

      // Update asset records based on discovered hosts
      const uniqueHosts = [...new Set(vulnerabilities.map(v => v.host))];
      
      for (const host of uniqueHosts) {
        // Check if host already exists
        const { data: existingAsset, error: assetCheckError } = await supabase
          .from('nessus_assets')
          .select('id')
          .eq('host_name', host)
          .maybeSingle();
          
        if (assetCheckError) {
          console.error('Error checking for existing asset:', assetCheckError);
          continue;
        }
        
        if (!existingAsset) {
          // Create new asset - ensure scanId is a string
          const sessionId = scanData?.[0]?.id ? String(scanData[0].id) : scanId;
          
          await supabase
            .from('nessus_assets')
            .insert({
              host_name: host,
              upload_session_id: sessionId,
              ip_address: /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(host) ? host : null,
              vulnerability_count: vulnerabilities.filter(v => v.host === host).length,
              risk_score: calculateRiskScore(vulnerabilities.filter(v => v.host === host))
            });
        } else {
          // Update vulnerability count for existing asset
          const hostVulnerabilities = vulnerabilities.filter(v => v.host === host);
          
          try {
            const { data: incrementResult, error: incrementError } = await supabase.rpc('increment_vulnerability_count', { 
              asset_id: existingAsset.id,
              increment_by: hostVulnerabilities.length 
            });
            
            if (incrementError) throw incrementError;
            
            const newCount = typeof incrementResult === 'number' ? incrementResult : 0;
            
            await supabase
              .from('nessus_assets')
              .update({
                vulnerability_count: newCount,
                risk_score: calculateRiskScore(hostVulnerabilities),
                updated_at: new Date().toISOString()
              })
              .eq('id', existingAsset.id);
          } catch (error) {
            console.error('Error updating asset vulnerability count:', error);
          }
        }
      }

      toast({
        title: "Results Uploaded Successfully",
        description: `Processed ${vulnerabilities.length} vulnerabilities from ${file.name}`,
      });

      // Create notification for admin users about new vulnerabilities
      const { data: admins } = await supabase
        .from('profiles')
        .select('id')
        .eq('role', 'admin')
        .eq('status', 'approved');

      if (admins && admins.length > 0) {
        const notifications = admins.map(admin => ({
          user_id: admin.id,
          title: 'New Vulnerabilities Detected',
          message: `${vulnerabilities.length} new vulnerabilities uploaded from scan: ${scanName || file.name}`,
          is_read: false,
          related_item_type: 'nuclei_scan',
          related_item_id: scanData?.[0]?.id ? String(scanData[0].id) : scanId
        }));

        await supabase.from('user_notifications').insert(notifications);
      }

      // Clear the form
      setScanName("");
      setTargetInputs("");
      event.target.value = "";
      
      // Refresh the recent scans list
      fetchRecentScans();

    } catch (error: any) {
      console.error('Upload error:', error);
      toast({
        title: "Upload Failed",
        description: error.message || "Failed to process the results file",
        variant: "destructive",
      });
    } finally {
      setIsUploading(false);
    }
  };

  const calculateRiskScore = (vulnerabilities: any[]): number => {
    const severityWeights: Record<string, number> = {
      critical: 10,
      high: 7,
      medium: 4,
      low: 1,
      info: 0.1,
      unknown: 0.5
    };

    const score = vulnerabilities.reduce((total, vuln) => {
      const severity = vuln.severity?.toLowerCase() || 'unknown';
      return total + (severityWeights[severity] || 0.5);
    }, 0);

    return parseFloat(score.toFixed(2));
  };

  const startScan = async () => {
    if (!scanName.trim() || !targetInputs.trim()) {
      toast({
        title: "Missing Information",
        description: "Please fill in scan name and targets",
        variant: "destructive",
      });
      return;
    }

    setIsScanning(true);
    setScanProgress(0);
    
    toast({
      title: "Scan Started",
      description: `Executing nuclei scan: ${scanName}`,
    });

    // Simulate scan progress
    const interval = setInterval(() => {
      setScanProgress(prev => {
        if (prev >= 100) {
          clearInterval(interval);
          setIsScanning(false);
          toast({
            title: "Scan Completed",
            description: "Nuclei scan finished successfully",
          });
          return 100;
        }
        return prev + Math.random() * 8;
      });
    }, 2000);
  };

  const stopScan = () => {
    setIsScanning(false);
    setScanProgress(0);
    toast({
      title: "Scan Stopped",
      description: "Nuclei scan has been terminated",
    });
  };

  const restrictSpaces = (value: string) => {
    return value.replace(/\s/g, '');
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-white">Nuclei Vulnerability Scanner</h1>
          <p className="text-slate-400">Configure and execute nuclei scans against target systems</p>
        </div>
        <div className="flex items-center gap-4">
          <NotificationCenter />
          
          <Button 
            variant="outline" 
            size="sm" 
            className="border-slate-600 gap-2"
            asChild
          >
            <a href="/vulnerabilities/nuclei">
              <AlertTriangle className="h-4 w-4" />
              View Vulnerabilities
            </a>
          </Button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Nuclei Scanner Configuration */}
        <div className="lg:col-span-2">
          <Card className="bg-slate-800 border-slate-700">
            <CardHeader>
              <CardTitle className="text-white flex items-center gap-2">
                <Scan className="h-5 w-5" />
                Nuclei Vulnerability Scanner
              </CardTitle>
              <CardDescription className="text-slate-400">
                Configure and execute nuclei scans against VM at 10.0.0.1
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              {/* Scan Type Selection */}
              <div>
                <Label className="text-slate-300 mb-3 block">Scan Type</Label>
                <Select value={selectedScanType} onValueChange={setSelectedScanType}>
                  <SelectTrigger className="bg-slate-700 border-slate-600 text-white">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent className="bg-slate-700 border-slate-600">
                    {scanTypes.map((type) => (
                      <SelectItem key={type.id} value={type.id} className="text-white">
                        <div>
                          <div className="font-medium">{type.name}</div>
                          <div className="text-xs text-slate-400">{type.path}</div>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <p className="text-xs text-slate-400 mt-1">
                  {scanTypes.find(type => type.id === selectedScanType)?.description}
                </p>
              </div>

              {/* Scan Options */}
              <div className="space-y-4">
                <div>
                  <Label htmlFor="scanName" className="text-slate-300">Scan Name</Label>
                  <Input
                    id="scanName"
                    placeholder="Enter scan name (no spaces)"
                    value={scanName}
                    onChange={(e) => setScanName(restrictSpaces(e.target.value))}
                    className="bg-slate-700 border-slate-600 text-white mt-1"
                  />
                </div>

                <div>
                  <Label htmlFor="targets" className="text-slate-300">Target IPs or URLs</Label>
                  <Textarea
                    id="targets"
                    placeholder="Enter targets (one per line)&#10;example.com&#10;192.168.1.100&#10;subdomain.example.com"
                    value={targetInputs}
                    onChange={(e) => setTargetInputs(e.target.value)}
                    className="bg-slate-700 border-slate-600 text-white mt-1 min-h-[100px]"
                  />
                  <div className="flex items-center gap-2 mt-2">
                    <Label htmlFor="targetFile" className="text-slate-400 text-sm cursor-pointer flex items-center gap-1">
                      <Upload className="h-3 w-3" />
                      Upload .txt file
                    </Label>
                    <Input
                      id="targetFile"
                      type="file"
                      accept=".txt"
                      onChange={handleFileUpload}
                      className="hidden"
                    />
                  </div>
                </div>
              </div>

              {/* Scan Controls */}
              <div className="pt-4 border-t border-slate-700">
                {isScanning ? (
                  <div className="space-y-4">
                    <div className="flex items-center justify-between">
                      <span className="text-slate-300">Nuclei scan in progress...</span>
                      <Badge variant="secondary" className="bg-blue-500/20 text-blue-400">
                        {scanProgress.toFixed(0)}% Complete
                      </Badge>
                    </div>
                    <Progress value={scanProgress} className="h-2" />
                    <div className="flex gap-2">
                      <Button variant="outline" onClick={stopScan} className="border-slate-600">
                        <Square className="h-4 w-4 mr-2" />
                        Stop Scan
                      </Button>
                    </div>
                  </div>
                ) : (
                  <div className="flex gap-2">
                    <Button onClick={startScan} className="bg-blue-600 hover:bg-blue-700">
                      <Play className="h-4 w-4 mr-2" />
                      Execute Scan
                    </Button>
                  </div>
                )}
              </div>

              {/* Result Upload Section */}
              <div className="pt-4 border-t border-slate-700">
                <div className="space-y-4">
                  <Label className="text-slate-300 text-lg font-medium">Upload Scan Results</Label>
                  <p className="text-slate-400 text-sm">
                    Upload nuclei scan results in JSON or JSONL format to import vulnerabilities into the system.
                  </p>
                  
                  <div className="flex items-center gap-4">
                    <Label htmlFor="resultFile" className="cursor-pointer">
                      <Button variant="outline" className="border-slate-600" disabled={isUploading} asChild>
                        <span>
                          <Upload className="h-4 w-4 mr-2" />
                          {isUploading ? "Uploading..." : "Upload Results"}
                        </span>
                      </Button>
                    </Label>
                    <Input
                      id="resultFile"
                      type="file"
                      accept=".json,.jsonl"
                      onChange={handleResultUpload}
                      className="hidden"
                      disabled={isUploading}
                    />
                    <span className="text-slate-400 text-sm">(.json or .jsonl files)</span>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Scan Queue & Status */}
        <div>
          <Card className="bg-slate-800 border-slate-700">
            <CardHeader>
              <CardTitle className="text-white">Recent Nuclei Scans</CardTitle>
              <CardDescription className="text-slate-400">
                Monitor scan status and history
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-3">
                {recentScans.length === 0 ? (
                  <div className="text-center py-6">
                    <Scan className="h-8 w-8 mx-auto mb-2 text-slate-600" />
                    <p className="text-slate-400">No recent scans</p>
                  </div>
                ) : (
                  recentScans.map((scan) => (
                    <div key={scan.id} className="p-3 rounded-lg bg-slate-700/50 border border-slate-600">
                      <div className="flex items-center justify-between mb-2">
                        <span className="text-slate-300 text-sm font-medium">{scan.scan_name}</span>
                        <Badge variant="secondary" className="bg-blue-500/20 text-blue-400">
                          Completed
                        </Badge>
                      </div>
                      <div className="text-xs text-slate-400 space-y-1">
                        <div>Type: {scan.scan_type}</div>
                        <div>Date: {new Date(scan.created_at).toLocaleString()}</div>
                        {scan.vulnerabilities > 0 ? (
                          <div className="text-orange-400">
                            {scan.vulnerabilities} vulnerabilities found
                          </div>
                        ) : (
                          <div className="text-green-400">
                            No vulnerabilities detected
                          </div>
                        )}
                      </div>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
