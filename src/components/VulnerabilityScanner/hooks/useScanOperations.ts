
import { useState } from "react";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { calculateRiskScore } from "../utils/scanUtils";

export const useScanOperations = () => {
  const { toast } = useToast();

  const handleFileUpload = (
    event: React.ChangeEvent<HTMLInputElement>,
    setTargetInputs: (value: string) => void
  ) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (!file.name.endsWith('.txt')) {
      toast({
        title: "Invalid File Type",
        description: "Please upload a .txt file containing target URLs/IPs",
        variant: "destructive",
      });
      return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
      const content = e.target?.result as string;
      setTargetInputs(content);
      toast({
        title: "File Uploaded",
        description: `Loaded ${content.split('\n').filter(line => line.trim()).length} targets from file`,
      });
    };
    reader.readAsText(file);
  };

  const handleResultUpload = async (
    event: React.ChangeEvent<HTMLInputElement>,
    scanName: string,
    selectedScanType: string,
    setScanName: (value: string) => void,
    setTargetInputs: (value: string) => void,
    setIsUploading: (value: boolean) => void,
    fetchRecentScans: () => void
  ) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (!file.name.endsWith('.json') && !file.name.endsWith('.jsonl')) {
      toast({
        title: "Invalid File Type",
        description: "Please upload a .json or .jsonl file containing nuclei scan results",
        variant: "destructive",
      });
      return;
    }

    setIsUploading(true);

    try {
      const content = await file.text();
      let results;

      // Handle both JSON and JSONL formats
      if (file.name.endsWith('.jsonl')) {
        // Parse JSONL (each line is a JSON object)
        results = content.split('\n')
          .filter(line => line.trim())
          .map(line => {
            try {
              return JSON.parse(line);
            } catch (e: any) {
              throw new Error(`Invalid JSONL format: ${e.message}`);
            }
          });
      } else {
        // Parse regular JSON
        try {
          results = JSON.parse(content);
        } catch (e: any) {
          throw new Error(`Invalid JSON format: ${e.message}`);
        }
      }

      // Ensure results is an array
      if (!Array.isArray(results)) {
        results = [results];
      }

      // Store the scan results
      const scanId = `scan_${Date.now()}`;
      const { data: scanData, error: scanError } = await supabase
        .from('nuclei_scan_results')
        .insert({
          scan_name: scanName || `Uploaded scan ${new Date().toLocaleString()}`,
          scan_type: selectedScanType,
          results: results
        })
        .select();

      if (scanError) throw scanError;

      // Get the actual scan ID with proper type checking and explicit casting
      const actualScanId: string = scanData?.[0]?.id ? String(scanData[0].id) : scanId;

      // Process each vulnerability from the results
      const vulnerabilities = results.map((result: any) => ({
        scan_id: actualScanId,
        vuln_id: result.id || result['template-id'] || 'unknown',
        template_name: result.info?.name || result.name || 'Unknown',
        vuln_hash: result.hash || `${result.host}_${result['template-id']}_${Date.now()}`,
        matcher_name: result['matcher-name'] || result.matcher,
        matcher_status: result['matcher-status'] !== false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        severity: result.info?.severity || result.severity || 'info',
        host: result.host || 'unknown',
        matched_at: result['matched-at'] || result.timestamp || new Date().toISOString(),
        template_id: result['template-id'] || result.template || result.id || 'unknown',
        description: result.info?.description || result.description || '',
        vuln_status: 'open'
      }));

      // Insert vulnerabilities
      const { error: vulnError } = await supabase
        .from('nuclei_vulnerabilities')
        .insert(vulnerabilities);

      if (vulnError) throw vulnError;

      // Update asset records based on discovered hosts
      const uniqueHosts = [...new Set(vulnerabilities.map(v => v.host))];
      
      for (const host of uniqueHosts) {
        // Check if host already exists
        const { data: existingAsset, error: assetCheckError } = await supabase
          .from('nessus_assets')
          .select('id')
          .eq('fqdn', host)
          .maybeSingle();
          
        if (assetCheckError) {
          console.error('Error checking for existing asset:', assetCheckError);
          continue;
        }
        
        if (!existingAsset) {
          // Create new asset with proper property names
          await supabase
            .from('nessus_assets')
            .insert({
              fqdn: host,
              upload_session_id: actualScanId,
              ip_address: /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(host) ? host : null,
              vulnerability_count: vulnerabilities.filter(v => v.host === host).length,
              risk_score: calculateRiskScore(vulnerabilities.filter(v => v.host === host))
            });
        } else {
          // Update vulnerability count for existing asset
          const hostVulnerabilities = vulnerabilities.filter(v => v.host === host);
          
          try {
            const { data: incrementResult, error: incrementError } = await supabase.rpc('increment_vulnerability_count', { 
              asset_id: existingAsset.id,
              increment_by: hostVulnerabilities.length 
            });
            
            if (incrementError) throw incrementError;
            
            const newCount = typeof incrementResult === 'number' ? incrementResult : 0;
            
            await supabase
              .from('nessus_assets')
              .update({
                vulnerability_count: newCount,
                risk_score: calculateRiskScore(hostVulnerabilities),
                updated_at: new Date().toISOString()
              })
              .eq('id', existingAsset.id);
          } catch (error) {
            console.error('Error updating asset vulnerability count:', error);
          }
        }
      }

      toast({
        title: "Results Uploaded Successfully",
        description: `Processed ${vulnerabilities.length} vulnerabilities from ${file.name}`,
      });

      // Create notification for admin users about new vulnerabilities
      const { data: admins } = await supabase
        .from('profiles')
        .select('id')
        .eq('role', 'admin')
        .eq('status', 'approved');

      if (admins && admins.length > 0) {
        const notifications = admins.map(admin => ({
          user_id: admin.id,
          title: 'New Vulnerabilities Detected',
          message: `${vulnerabilities.length} new vulnerabilities uploaded from scan: ${scanName || file.name}`,
          is_read: false,
          related_item_type: 'nuclei_scan',
          related_item_id: actualScanId
        }));

        await supabase.from('user_notifications').insert(notifications);
      }

      // Clear the form
      setScanName("");
      setTargetInputs("");
      event.target.value = "";
      
      // Refresh the recent scans list
      fetchRecentScans();

    } catch (error: any) {
      console.error('Upload error:', error);
      toast({
        title: "Upload Failed",
        description: error.message || "Failed to process the results file",
        variant: "destructive",
      });
    } finally {
      setIsUploading(false);
    }
  };

  return {
    handleFileUpload,
    handleResultUpload
  };
};
